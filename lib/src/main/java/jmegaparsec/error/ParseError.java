package jmegaparsec.error;

import jmegaparsec.Token;
import jmegaparsec.support.Semigroup;

import javax.annotation.Nonnull;
import java.util.Comparator;
import java.util.function.BinaryOperator;

/**
 * ParseError represents a parse error.
 *
 * 'Semigroup' and 'Monoid' instances of the data type allow us to merge
 * parse errors from different branches of parsing. When merging two
 * 'ParseError's, the longest match is preferred; if positions are the same,
 * custom data sets and collections of message items are combined. Note that
 * fancy errors take precedence over trivial errors in merging.
 *
 * @since 7.0.0
 * 
 * @param <S> stream type
 * @param <E> custom data
 */
public abstract class ParseError<S extends Token & Comparable<S>, E extends Comparable<E>> implements BinaryOperator<ParseError<S, E>> {
    /**
     * Trivial errors, generated by the Megaparsec's machinery. The data
     * constructor includes the offset of error, unexpected token (if any),
     * and expected tokens.
     *
     * Type of the first argument was changed in the version /7.0.0/.
     * @param <S> stream type
     */
    static class TrivialError<S> extends ParseError<S, Void> {
        TrivialError(int i, 
                     Optional<ErrorItem<Token<S>>> errorItem, 
                     Set<ErrorItem<Token<S>>> errorItems) {}
    }

    /**
     * Fancy, custom errors.
     *
     * Type of the first argument was changed in the version /7.0.0/.
     */
    static class FancyError<E> extends ParseError<Void, E> {
        
    }
    
    ParseError(S s, E e) {
        this.token = s;
        this.errorData = e;
    }

    @Override
    public ParseError<S, E> apply(ParseError<S, E> seParseError, ParseError<S, E> seParseError2) {
        return mergeError(seParseError, seParseError2);
    }
}
